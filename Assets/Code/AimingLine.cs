using UnityEngine;

/// <summary>
/// Class defining the behaviour of the aiming line
/// The aiming line uses a LineRender to display a projected path the projectile's will take when launched, up to and including their first bounce
/// The projection updates as the player changes their aim angle
/// Requires components: LineRenderer
/// </summary>
[RequireComponent(typeof(LineRenderer))]
public class AimingLine : MonoBehaviour
{
    /// <summary>
    /// Reference to the object's LineRenderer component
    /// </summary>
    private LineRenderer m_lineRenderer = null;
    /// <summary>
    /// Stores the radius of a projectile
    /// Used to set the width of the aiming line
    /// </summary>
    private float m_projectileRadius = 0.0f;
    /// <summary>
    /// Refernece to a projectile
    /// Used to set values such as m_projectileRadius
    /// Set in Inspector
    /// </summary>
    [SerializeField]
    private GameObject m_projectile = null;
    /// <summary>
    /// Layermask of layer's the aiming line will simular collisions against
    /// </summary>
    [SerializeField]
    private LayerMask m_layers;
    /// <summary>
    /// The maximum length of the aiming line
    /// </summary>
    [SerializeField]
    private float m_maxDistance = 1000f;
    /// <summary>
    /// Multiplier for the length of the second half of the aiming line
    /// The second half shows the projected direction of the projectile's first bounce
    /// </summary>
    [SerializeField]
    private float m_lengthMultiplier = 0.25f;

    /// <summary>
    /// Gets references and sets values
    /// </summary>
    private void Awake()
    {
        /// Gets a reference to object's LineRenderer
        m_lineRenderer = GetComponent<LineRenderer>();
        /// Gets the radius of a projectile by accessing its SphereCollider component's radius property. Multipliers by the z value of projectile's transform's localScale to make it accurate regardless of if the projectile has had its scale adjusted
        /// Since projectiles are perfect spheres, only one of the localScale values needs to checked
        m_projectileRadius = m_projectile.GetComponent<SphereCollider>().radius * m_projectile.GetComponent<Transform>().localScale.z;

        /// Sets the start and end width of the line generated by the LineRenderer
        /// Width is equal to the diameter of a projectile, calculated by multiplying the radius value by 2
        m_lineRenderer.startWidth = m_projectileRadius * 2 * m_lineRenderer.gameObject.GetComponent<Transform>().localScale.z;
        m_lineRenderer.endWidth = m_projectileRadius * 2 * m_lineRenderer.gameObject.GetComponent<Transform>().localScale.z;
    }

    /// <summary>
    /// Enables or disables the aim line
    /// Draws the aim line
    /// </summary>
    private void Update()
    {
        SetAimLineState();
        DrawAimLine();
    }

    /// <summary>
    /// Enables or disables the aim line depending on whether play is enabled in the GameManager
    /// In effect, the aim line is not drawn while there is a projectile active, when the player clears a level, or during a game over
    /// </summary>
    private void SetAimLineState()
    {
        /// If play is enabled, then enables the LineRender component if it was disabled
        if (GameManager.Instance.EnablePlay)
        {
            if (m_lineRenderer.enabled == false)
            {
                m_lineRenderer.enabled = true;
            }
        }
        /// If play is disabled, then disabled the lineRenderer if it was enabled
        else
        {
            if (m_lineRenderer.enabled)
            {
                m_lineRenderer.enabled = false;
            }
        }
    }

    /// <summary>
    /// Draws the aim line, updating its position as the player changes their aim angle
    /// If the line hits a collidable object, draws a second section showing the projected direction of a projectile bounce if it were to collide with that object
    /// A sphere cast is used to project the path of the projectile, as it is closest to the shape of the projectile
    /// </summary>
    private void DrawAimLine()
    {
        /// Stores information about the target hit by the sphere cast
        RaycastHit _hit;

        /// If the sphere cast hits a collidable object, draws the second section projecting the bounce
        if (Physics.SphereCast(transform.position, m_projectileRadius, transform.forward, out _hit, m_maxDistance, m_layers))
        {
            /// Vector representing the direction from the start of the aim line (the launcher) to the point on the object the sphere cast hit
            Vector3 _incomingVec = _hit.point - transform.position;

            /// Vector representing the projectile bounce direction
            /// Calculated by reflecting the direction from the aim line start to the point on object that it, reflected in that object's normal
            Vector3 _reflectVec = Vector3.Reflect(_incomingVec, _hit.normal);
                 
            //Debug.DrawLine(transform.position, _hit.point, Color.red);
            //Debug.DrawRay(_hit.point, _reflectVec);

            /// Uses the LineRenderer to draw two lines between three points
            /// The first line is from the launcher to the hit point on the object, and the second is from that point to another in the projected bounce direction
            m_lineRenderer.SetPosition(0, transform.position);
            m_lineRenderer.SetPosition(1, _hit.point);
            m_lineRenderer.SetPosition(2, _hit.point + _reflectVec * m_lengthMultiplier);
        }
    }
}
