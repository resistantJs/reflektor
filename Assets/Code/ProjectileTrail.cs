using UnityEngine;

/// <summary>
/// Class defining the behaviour the projectile trail
/// While active, projectile's leave behind a visual trail that lingers for a short period before disappearing
/// Requires components: TrailRenderer
/// </summary>
[RequireComponent(typeof(TrailRenderer))]
public class ProjectileTrail : MonoBehaviour 
{
    /// <summary>
    /// Reference to a projectile
    /// Initialised in Inspector
    /// </summary>
    [SerializeField]
    private GameObject m_projectile = null;
    /// <summary>
    /// Reference to the TrailRenderer component attached to this object
    /// </summary>
    private TrailRenderer m_trailRender = null;
    /// <summary>
    /// The radius of a projectile
    /// Used to set the width of the trail
    /// </summary>
    private float m_projectileRadius = 0.0f;

    /// <summary>
    /// Sets the width of the trail
    /// </summary>
    private void Awake()
    {
        /// Gets a reference to the TrailRenderer component
        m_trailRender = GetComponent<TrailRenderer>();

        /// Gets the radius of a projectile by accessing its SphereCollider component's radius property. Multipliers by the z value of projectile's transform's localScale to make it accurate regardless of if the projectile has had its scale adjusted
        /// Since projectiles are perfect spheres, only one of the localScale values needs to checked
        m_projectileRadius = m_projectile.GetComponent<SphereCollider>().radius * m_projectile.GetComponent<Transform>().localScale.z;

        /// Sets the start and end width of the trail generated by the TrailRenderer
        /// Width is equal to the diameter of a projectile, calculated by multiplying the radius value by 2
        m_trailRender.startWidth = m_projectileRadius * 2 * m_trailRender.gameObject.GetComponent<Transform>().localScale.z;
        m_trailRender.endWidth = m_projectileRadius * 2 * m_trailRender.gameObject.GetComponent<Transform>().localScale.z;
    }
}
